%!TEX root = ts.tex

\rSec0[buffer.stream]{Buffer-oriented streams}


\rSec1[buffer.stream.reqmts]{Requirements}


\rSec2[buffer.stream.reqmts.syncreadstream]{Buffer-oriented synchronous read stream requirements}

\indextext{requirements!\idxnewoldconcept{SyncReadStream}}%
\pnum
A type \tcode{X} meets the \defnnewoldconcept{SyncReadStream} requirements if it meets the requirements listed in Table~\ref{tab:buffer.stream.reqmts.syncreadstream.requirements}.

\pnum
An \defn{orderly shutdown} is
the procedure for shutting down a stream after all work in progress has been completed, without loss of data.

\pnum
In Table~\ref{tab:buffer.stream.reqmts.syncreadstream.requirements},
\tcode{a} denotes a value of type \tcode{X},
\tcode{mb} denotes a  value of a (possibly const) type meeting the \newoldconcept{MutableBufferSequence}~(\ref{buffer.reqmts.mutablebuffersequence}) requirements,
and \tcode{ec} denotes an object of type \tcode{error_code}.

\indexlibrary{\idxcode{read_some}}%
\begin{libreqtab3}
{\newoldconcept{SyncReadStream} requirements}
{tab:buffer.stream.reqmts.syncreadstream.requirements}
\\ \topline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions} \\ \capsep
\endhead

\tcode{a.read_some(mb)}
\tcode{a.read_some(mb,ec)}  &
\tcode{size_t}  &
Meets the requirements for a read operation~(\ref{buffer.reqmts.read.write}).\br
If \tcode{buffer_size(mb) > 0}, reads one or more bytes of data from the stream \tcode{a} into the buffer sequence \tcode{mb}. If successful, sets \tcode{ec} such that \tcode{!ec} is \tcode{true}, and returns the number of bytes read. If an error occurred, sets \tcode{ec} such that \tcode{!!ec} is \tcode{true}, and returns 0. If all data has been read from the stream, and the stream performed an orderly shutdown, sets \tcode{ec} to \tcode{stream_errc::eof} and returns 0. If \tcode{buffer_size(mb) == 0}, the operation shall not block. Sets \tcode{ec} such that \tcode{!ec} is \tcode{true}, and returns 0.  \\

\end{libreqtab3}


\rSec2[buffer.stream.reqmts.asyncreadstream]{Buffer-oriented asynchronous read stream requirements}

\indextext{requirements!\idxnewoldconcept{AsyncReadStream}}%
\pnum
A type \tcode{X} meets the \defnnewoldconcept{AsyncReadStream} requirements if it meets the requirements listed below.

\pnum
In the table below, \tcode{a} denotes a value of type \tcode{X},
\tcode{mb} denotes a  value of a (possibly const) type meeting the \newoldconcept{MutableBufferSequence}~(\ref{buffer.reqmts.mutablebuffersequence}) requirements,
and \tcode{t} is a completion token.

\indexlibrary{\idxcode{get_executor}}%
\indexlibrary{\idxcode{async_read_some}}%
\begin{libreqtab3}
{\newoldconcept{AsyncReadStream} requirements}
{tab:buffer.stream.reqmts.asyncreadstream.requirements}
\\ \topline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions}  \\ \capsep
\endhead

\tcode{a.get_executor()}  &
A type meeting the \newoldconcept{Executor} requirements~(\ref{async.reqmts.executor}).  &
 Returns the associated I/O executor.  \\ \rowsep

\tcode{a.async_read_some(mb,t)}  &
The return type is determined according to the requirements for an asynchronous operation~(\ref{async.reqmts.async}).  &
Meets the requirements for a read operation~(\ref{buffer.reqmts.read.write}) and an asynchronous operation~(\ref{async.reqmts.async}) with completion signature \tcode{void(error_code ec, size_t n)}.\br
If \tcode{buffer_size(mb) > 0}, initiates an asynchronous operation to read one or more bytes of data from the stream \tcode{a} into the buffer sequence \tcode{mb}. If successful, \tcode{ec} is set such that \tcode{!ec} is \tcode{true}, and \tcode{n} is the number of bytes read. If an error occurred, \tcode{ec} is set such that \tcode{!!ec} is \tcode{true}, and \tcode{n} is 0. If all data has been read from the stream, and the stream performed an orderly shutdown, \tcode{ec} is \tcode{stream_errc::eof} and \tcode{n} is 0. If \tcode{buffer_size(mb) == 0}, the operation completes immediately. \tcode{ec} is set such that \tcode{!ec} is \tcode{true}, and \tcode{n} is 0.  \\

\end{libreqtab3}


\rSec2[buffer.stream.reqmts.syncwritestream]{Buffer-oriented synchronous write stream requirements}

\indextext{\idxnewoldconcept{SyncWriteStream}}%
\indextext{requirements!\idxnewoldconcept{SyncWriteStream}}%
\pnum
A type \tcode{X} meets the \defnnewoldconcept{SyncWriteStream} requirements if it meets the requirements listed below.

\pnum
In the table below,
\tcode{a} denotes a value of type \tcode{X},
\tcode{cb} denotes a  value of a (possibly const) type meeting the \newoldconcept{ConstBufferSequence}~(\ref{buffer.reqmts.constbuffersequence}) requirements,
and \tcode{ec} denotes an object of type \tcode{error_code}.

\indexlibrary{\idxcode{write_some}}%
\begin{libreqtab3}
{\newoldconcept{SyncWriteStream} requirements}
{tab:buffer.stream.reqmts.syncwritestream.requirements}
\\ \topline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions} \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions} \\ \capsep
\endhead

\tcode{a.write_some(cb)}
\tcode{a.write_some(cb,ec)}  &
\tcode{size_t}  &
Meets the requirements for a write operation~(\ref{buffer.reqmts.read.write}).\br
If \tcode{buffer_size(cb) > 0}, writes one or more bytes of data to the stream \tcode{a} from the buffer sequence \tcode{cb}. If successful, sets \tcode{ec} such that \tcode{!ec} is \tcode{true}, and returns the number of bytes written. If an error occurred, sets \tcode{ec} such that \tcode{!!ec} is \tcode{true}, and returns 0. If \tcode{buffer_size(cb) == 0}, the operation shall not block. Sets \tcode{ec} such that \tcode{!ec} is \tcode{true}, and returns 0.  \\

\end{libreqtab3}



\rSec2[buffer.stream.reqmts.asyncwritestream]{Buffer-oriented asynchronous write stream requirements}

\indextext{requirements!\idxnewoldconcept{AsyncWriteStream}}%
\pnum
A type \tcode{X} meets the \defnnewoldconcept{AsyncWriteStream} requirements if it meets the requirements listed below.

\pnum
In the table below,
\tcode{a} denotes a value of type \tcode{X},
\tcode{cb} denotes a  value of a (possibly const) type meeting the \newoldconcept{ConstBufferSequence}~(\ref{buffer.reqmts.constbuffersequence}) requirements,
and \tcode{t} is a completion token.

\indexlibrary{\idxcode{get_executor}}%
\indexlibrary{\idxcode{async_write_some}}%
\begin{libreqtab3}
{\newoldconcept{AsyncWriteStream} requirements}
{tab:buffer.stream.reqmts.asyncwritestream.requirements}
\\ \topline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions}  \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{operation}  &
\chdr{type}  &
\rhdr{semantics, pre/post-conditions}  \\ \capsep
\endhead

\tcode{a.get_executor()}  &
A type meeting the \newoldconcept{Executor} requirements~(\ref{async.reqmts.executor}).  &
 Returns the associated I/O executor.  \\ \rowsep

\tcode{a.async_write_some(cb,t)}  &
The return type is determined according to the requirements for an asynchronous operation~(\ref{async.reqmts.async}).  &
Meets the requirements for a write operation~(\ref{buffer.reqmts.read.write}) and an asynchronous operation~(\ref{async.reqmts.async}) with completion signature \tcode{void(error_code ec, size_t n)}.\br
If \tcode{buffer_size(cb) > 0}, initiates an asynchronous operation to write one or more bytes of data to the stream \tcode{a} from the buffer sequence \tcode{cb}. If successful, \tcode{ec} is set such that \tcode{!ec} is \tcode{true}, and \tcode{n} is the number of bytes written. If an error occurred, \tcode{ec} is set such that \tcode{!!ec} is \tcode{true}, and \tcode{n} is 0. If \tcode{buffer_size(cb) == 0}, the operation completes immediately. \tcode{ec} is set such that \tcode{!ec} is \tcode{true}, and \tcode{n} is 0.  \\

\end{libreqtab3}



\rSec2[buffer.stream.reqmts.completioncondition]{Completion condition requirements}

\indextext{requirements!\idxnewoldconcept{CompletionCondition}}%
\pnum
A completion condition is a function object that is used with the algorithms \tcode{read}~(\ref{buffer.read}), \tcode{async_read}~(\ref{buffer.async.read}), \tcode{write}~(\ref{buffer.write}), and \tcode{async_write}~(\ref{buffer.async.write}) to determine when the algorithm has completed transferring data.

\pnum
A type \tcode{X} meets the \defnnewoldconcept{CompletionCondition} requirements if it meets the requirements of \oldconcept{Destructible} (\CppXref{destructible}) and \oldconcept{CopyConstructible} (\CppXref{copyconstructible}), as well as the additional requirements listed below.

\pnum
In the table below, \tcode{x} denotes a value of type \tcode{X},
\tcode{ec} denotes a  value of type (possibly const) \tcode{error_code},
and \tcode{n} denotes a  value of type (possibly const) \tcode{size_t}.

\begin{libreqtab3}
{\newoldconcept{CompletionCondition} requirements}
{tab:buffer.stream.reqmts.completioncondition.requirements}
\\ \topline
\lhdr{expression}  &
\chdr{return type}  &
\rhdr{assertion/note pre/post-condition}  \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{expression}  &
\chdr{return type}  &
\rhdr{assertion/note pre/post-condition} \\ \capsep
\endhead

\tcode{x(ec, n)}  &
\tcode{size_t}  &
Let \tcode{n} be the total number of bytes transferred by the read or write algorithm so far.\br
Returns the maximum number of bytes to be transferred on the next \tcode{read_some}, \tcode{async_read_some}, \tcode{write_some}, or \tcode{async_write_some} operation performed by the algorithm. Returns \tcode{0} to indicate that the algorithm is complete.  \\

\end{libreqtab3}




\rSec1[buffer.stream.transfer.all]{Class \tcode{transfer_all}}

\indexlibrary{\idxcode{transfer_all}}%
\pnum
The class \tcode{transfer_all} is a completion condition that is used to specify that a read or write operation should continue until all of the data has been transferred, or until an error occurs.

\begin{codeblock}
namespace std::experimental::net::inline @\namespacever@ {

  class transfer_all
  {
  public:
    size_t operator()(const error_code& ec, size_t) const;
  };

} // inline namespace std::experimental::net::\namespacever
\end{codeblock}

\pnum
The class \tcode{transfer_all} meets the \newoldconcept{CompletionCondition}~(\ref{buffer.stream.reqmts.completioncondition}) requirements.

\begin{itemdecl}
size_t operator()(const error_code& ec, size_t) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{!ec}, an unspecified non-zero value. Otherwise \tcode{0}.
\end{itemdescr}



\rSec1[buffer.stream.transfer.at.least]{Class \tcode{transfer_at_least}}

\indexlibrary{\idxcode{transfer_at_least}}%
\pnum
The class \tcode{transfer_at_least} is a completion condition that is used to specify that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs.

\begin{codeblock}
namespace std::experimental::net::inline @\namespacever@ {

  class transfer_at_least
  {
  public:
    explicit transfer_at_least(size_t m);
    size_t operator()(const error_code& ec, size_t n) const;
  private:
    size_t minimum_; // \expos
  };

} // inline namespace std::experimental::net::\namespacever
\end{codeblock}

\pnum
The class \tcode{transfer_at_least} meets the \newoldconcept{CompletionCondition}~(\ref{buffer.stream.reqmts.completioncondition}) requirements.

\begin{itemdecl}
explicit transfer_at_least(size_t m);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{minimum_ == m}.
\end{itemdescr}

\begin{itemdecl}
size_t operator()(const error_code& ec, size_t n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{!ec \&\& n < minimum_}, an unspecified non-zero value. Otherwise \tcode{0}.
\end{itemdescr}



\rSec1[buffer.stream.transfer.exactly]{Class \tcode{transfer_exactly}}

\indexlibrary{\idxcode{transfer_exactly}}%
\pnum
The class \tcode{transfer_exactly} is a completion condition that is used to specify that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs.

\begin{codeblock}
namespace std::experimental::net::inline @\namespacever@ {

  class transfer_exactly
  {
  public:
    explicit transfer_exactly(size_t e);
    size_t operator()(const error_code& ec, size_t n) const;
  private:
    size_t exact_; // \expos
  };

} // inline namespace std::experimental::net::\namespacever
\end{codeblock}

\pnum
The class \tcode{transfer_exactly} meets the \newoldconcept{CompletionCondition}~(\ref{buffer.stream.reqmts.completioncondition}) requirements.

\begin{itemdecl}
explicit transfer_exactly(size_t e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{exact_ == e}.
\end{itemdescr}

\begin{itemdecl}
size_t operator()(const error_code& ec, size_t n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns If \tcode{!ec \&\& n < exact_}, the result of \tcode{min(exact_ - n, N)}, where \tcode{N} is an unspecified non-zero value. Otherwise \tcode{0}.
\end{itemdescr}



\rSec1[buffer.read]{Synchronous read operations}

\indexlibrary{\idxcode{read}}%
\begin{itemdecl}
template<class SyncReadStream, class MutableBufferSequence>
  size_t read(SyncReadStream& stream,
              const MutableBufferSequence& buffers);
template<class SyncReadStream, class MutableBufferSequence>
  size_t read(SyncReadStream& stream,
              const MutableBufferSequence& buffers, error_code& ec);
template<class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition>
    size_t read(SyncReadStream& stream,
                const MutableBufferSequence& buffers,
                CompletionCondition completion_condition);
template<class SyncReadStream, class MutableBufferSequence,
  class CompletionCondition>
    size_t read(SyncReadStream& stream,
                const MutableBufferSequence& buffers,
                CompletionCondition completion_condition,
                error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
A read operation~(\ref{buffer.reqmts.read.write}).

\pnum
\constraints
\tcode{is_mutable_buffer_sequence_v<MutableBufferSequence>} is \tcode{true}.

\pnum
\effects Clears \tcode{ec}, then reads data from the buffer-oriented synchronous read stream~(\ref{buffer.stream.reqmts.syncreadstream}) object \tcode{stream} by performing zero or more calls to the stream's \tcode{read_some} member function.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each call to the stream's \tcode{read_some} member function. The completion condition is passed the \tcode{error_code} value from the most recent \tcode{read_some} call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent \tcode{read_some} call. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
The synchronous read operation continues until:

\begin{itemize}
\item
the total number of bytes transferred is equal to \tcode{buffer_size(buffers)}; or
\item
the completion condition returns \tcode{0}.
\end{itemize}

\pnum
On return, \tcode{ec} contains the \tcode{error_code} value from the most recent \tcode{read_some} call.

\pnum
\returns The total number of bytes transferred in the synchronous read operation.
\end{itemdescr}

\indexlibrary{\idxcode{read}}%
\begin{itemdecl}
template<class SyncReadStream, class DynamicBuffer>
  size_t read(SyncReadStream& stream, DynamicBuffer b);
template<class SyncReadStream, class DynamicBuffer>
  size_t read(SyncReadStream& stream, DynamicBuffer b, error_code& ec);
template<class SyncReadStream, class DynamicBuffer,
  class CompletionCondition>
    size_t read(SyncReadStream& stream, DynamicBuffer b,
                CompletionCondition completion_condition);
template<class SyncReadStream, class DynamicBuffer,
  class CompletionCondition>
    size_t read(SyncReadStream& stream, DynamicBuffer b,
                CompletionCondition completion_condition,
                error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_dynamic_buffer_v<Dynamic\-Buffer>} is \tcode{true}.

\pnum
\effects Clears \tcode{ec}, then reads data from the synchronous read stream~(\ref{buffer.stream.reqmts.syncreadstream}) object \tcode{stream} by performing zero or more calls to the stream's \tcode{read_some} member function.

\pnum
Data is placed into the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b}. A mutable buffer sequence~(\ref{buffer.reqmts.mutablebuffersequence}) \tcode{x} is obtained prior to each \tcode{read_some} call by performing:

\begin{codeblock}
auto orig_size = b.size();
b.grow(N);
auto x = b.data(orig_size, N);
\end{codeblock}

where \tcode{N} is an unspecified value less than or equal to \tcode{b.max_size() - b.size()}. \begin{note} Implementations can use \tcode{b.capacity()} when determining \tcode{N}, to minimize the number of \tcode{read_some} calls performed on the stream. \end{note} After each \tcode{read_some} call, the implementation performs \tcode{b.shrink(N - n)}, where \tcode{n} is the return value from \tcode{read_some}.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each call to the stream's \tcode{read_some} member function. The completion condition is passed the \tcode{error_code} value from the most recent \tcode{read_some} call, and the total number of bytes transferred in the synchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent \tcode{read_some} call. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
 The synchronous read operation continues until:

\begin{itemize}
\item \tcode{b.size() == b.max_size()}; or
\item the completion condition returns \tcode{0}.
\end{itemize}

\pnum
On return, \tcode{ec} contains the \tcode{error_code} value from the most recent \tcode{read_some} call.

\pnum
\returns The total number of bytes transferred in the synchronous read operation.
\end{itemdescr}



\rSec1[buffer.async.read]{Asynchronous read operations}

\indexlibrary{\idxcode{async_read}}%
\begin{itemdecl}
template<class AsyncReadStream, class MutableBufferSequence, class CompletionToken>
    @\DEDUCED@ async_read(AsyncReadStream& stream,
                       const MutableBufferSequence& buffers,
                       CompletionToken&& token);
template<class AsyncReadStream, class MutableBufferSequence, class CompletionCondition,
         class CompletionToken>
    @\DEDUCED@ async_read(AsyncReadStream& stream,
                       const MutableBufferSequence& buffers,
                       CompletionCondition completion_condition,
                       CompletionToken&& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
A composed asynchronous read operation~(\ref{async.reqmts.async.composed}, \ref{buffer.reqmts.read.write}).

\pnum
\completionsig \tcode{void(error_code ec, size_t n)}.

\pnum
\constraints
\tcode{is_mutable_buffer_sequence_v<MutableBufferSequence>} is \tcode{true}.

\pnum
\effects Reads data from the buffer-oriented asynchronous read stream~(\ref{buffer.stream.reqmts.asyncreadstream}) object \tcode{stream} by invoking the stream's \tcode{async_read_some} member function (henceforth referred to as asynchronous read_some operations) zero or more times.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the \tcode{error_code} value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
 This asynchronous read operation is outstanding until:

\begin{itemize}
\item
the total number of bytes transferred is equal to \tcode{buffer_size(buffers)}; or
\item
the completion condition returns \tcode{0}.
\end{itemize}

\pnum
The program shall ensure the \tcode{AsyncReadStream} object \tcode{stream} is valid until the completion handler for the asynchronous operation is invoked.

\pnum
On completion of the asynchronous operation, \tcode{ec} is the \tcode{error_code} value from the most recent asynchronous read_some operation, and \tcode{n} is the total number of bytes transferred.
\end{itemdescr}

\indexlibrary{\idxcode{async_read}}%
\begin{itemdecl}
template<class AsyncReadStream, class DynamicBuffer, class CompletionToken>
    @\DEDUCED@ async_read(AsyncReadStream& stream,
                       DynamicBuffer b, CompletionToken&& token);
template<class AsyncReadStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken>
    @\DEDUCED@ async_read(AsyncReadStream& stream,
                       DynamicBuffer b,
                       CompletionCondition completion_condition,
                       CompletionToken&& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
\completionsig \tcode{void(error_code ec, size_t n)}.

\pnum
\constraints
\tcode{is_dynamic_buffer_v<DynamicBuffer>} is \tcode{true}.

\pnum
\effects Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream~(\ref{buffer.stream.reqmts.asyncreadstream}) object \tcode{stream} by performing one or more asynchronous read_some operations on the stream.

\pnum
Data is placed into the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b}. A mutable buffer sequence~(\ref{buffer.reqmts.mutablebuffersequence}) \tcode{x} is obtained prior to each \tcode{async_read_some} call by performing:

\begin{codeblock}
auto orig_size = b.size();
b.grow(N);
auto x = b.data(orig_size, N);
\end{codeblock}

where \tcode{N} is an unspecified value such that \tcode{N} is less than or equal to \tcode{b.max_size() - b.size()}. \begin{note} Implementations can use \tcode{b.capacity()} when determining \tcode{N}, to minimize the number of asynchronous read_some operations performed on the stream. \end{note} After the completion of each asynchronous read_some operation, the implementation performs \tcode{b.shrink(N - n)}, where \tcode{n} is the value passed to the asynchronous read_some operation's completion handler.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each asynchronous read_some operation. The completion condition is passed the \tcode{error_code} value from the most recent asynchronous read_some operation, and the total number of bytes transferred in the asynchronous read operation so far. The completion condition return value specifies the maximum number of bytes to be read on the subsequent asynchronous read_some operation. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
 The asynchronous read operation is outstanding until:

\begin{itemize}
\item
\tcode{b.size() == b.max_size()}; or
\item
the completion condition returns \tcode{0}.
\end{itemize}

\pnum
The program shall ensure the \tcode{AsyncReadStream} object \tcode{stream} is valid until the completion handler for the asynchronous operation is invoked.

\pnum
On completion of the asynchronous operation, \tcode{ec} is the \tcode{error_code} value from the most recent asynchronous read_some operation, and \tcode{n} is the total number of bytes transferred.
\end{itemdescr}



\rSec1[buffer.write]{Synchronous write operations}

\indexlibrary{\idxcode{write}}%
\begin{itemdecl}
template<class SyncWriteStream, class ConstBufferSequence>
  size_t write(SyncWriteStream& stream,
               const ConstBufferSequence& buffers);
template<class SyncWriteStream, class ConstBufferSequence>
  size_t write(SyncWriteStream& stream,
               const ConstBufferSequence& buffers, error_code& ec);
template<class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition>
    size_t write(SyncWriteStream& stream,
                 const ConstBufferSequence& buffers,
                 CompletionCondition completion_condition);
template<class SyncWriteStream, class ConstBufferSequence,
  class CompletionCondition>
    size_t write(SyncWriteStream& stream,
                 const ConstBufferSequence& buffers,
                 CompletionCondition completion_condition,
                 error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
A write operation~(\ref{buffer.reqmts.read.write}).

\pnum
\constraints
\tcode{is_const_buffer_seq\-uence_v<ConstBufferSequence>} is \tcode{true}.

\pnum
\effects Writes data to the buffer-oriented synchronous write stream~(\ref{buffer.stream.reqmts.syncwritestream}) object \tcode{stream} by performing zero or more calls to the stream's \tcode{write_some} member function.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each call to the stream's \tcode{write_some} member function. The completion condition is passed the \tcode{error_code} value from the most recent \tcode{write_some} call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent \tcode{write_some} call. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
 The synchronous write operation continues until:

\begin{itemize}
\item
the total number of bytes transferred is equal to \tcode{buffer_size(buffers)}; or
\item
the completion condition returns \tcode{0}.
\end{itemize}

\pnum
On return, \tcode{ec} contains the \tcode{error_code} value from the most recent \tcode{write_some} call.

\pnum
\returns The total number of bytes transferred in the synchronous write operation.
\end{itemdescr}

\indexlibrary{\idxcode{write}}%
\begin{itemdecl}
template<class SyncWriteStream, class DynamicBuffer>
  size_t write(SyncWriteStream& stream, DynamicBuffer b);
template<class SyncWriteStream, class DynamicBuffer>
  size_t write(SyncWriteStream& stream, DynamicBuffer b, error_code& ec);
template<class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
  size_t write(SyncWriteStream& stream, DynamicBuffer b,
               CompletionCondition completion_condition);
template<class SyncWriteStream, class DynamicBuffer, class CompletionCondition>
  size_t write(SyncWriteStream& stream, DynamicBuffer b,
               CompletionCondition completion_condition,
               error_code& ec);
\end{itemdecl}

\begin{itemdescr}

\pnum
\constraints
\tcode{is_dynamic_buffer_v<Dynamic\-Buffer>} is \tcode{true}.

\pnum
\effects Writes data to the synchronous write stream~(\ref{buffer.stream.reqmts.syncwritestream}) object \tcode{stream} by performing zero or more calls to the stream's \tcode{write_some} member function.

\pnum
Data is written from the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b}. A constant buffer sequence~(\ref{buffer.reqmts.constbuffersequence}) is obtained using \tcode{b.data()}. After the data has been written to the stream, the implementation performs \tcode{b.consume(n)}, where \tcode{n} is the number of bytes successfully written.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called after each call to the stream's \tcode{write_some} member function. The completion condition is passed the \tcode{error_code} value from the most recent \tcode{write_some} call, and the total number of bytes transferred in the synchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent \tcode{write_some} call. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
The synchronous write operation continues until:

\begin{itemize}
\item \tcode{b.size() == 0}; or
\item the completion condition returns \tcode{0}.
\end{itemize}

\pnum
On return, \tcode{ec} contains the \tcode{error_code} value from the most recent \tcode{write_some} call.

\pnum
\returns The total number of bytes transferred in the synchronous write operation.
\end{itemdescr}



\rSec1[buffer.async.write]{Asynchronous write operations}

\indexlibrary{\idxcode{async_write}}%
\begin{itemdecl}
template<class AsyncWriteStream, class ConstBufferSequence, class CompletionToken>
    @\DEDUCED@ async_write(AsyncWriteStream& stream,
                        const ConstBufferSequence& buffers,
                        CompletionToken&& token);
template<class AsyncWriteStream, class ConstBufferSequence, class CompletionCondition,
         class CompletionToken>
    @\DEDUCED@ async_write(AsyncWriteStream& stream,
                        const ConstBufferSequence& buffers,
                        CompletionCondition completion_condition,
                        CompletionToken&& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
A composed asynchronous write operation~(\ref{async.reqmts.async.composed}, \ref{buffer.reqmts.read.write}).

\pnum
\completionsig \tcode{void(error_code ec, size_t n)}.

\pnum
\constraints
\tcode{is_const_buffer_seq\-uence_v<ConstBufferSequence>} is \tcode{true}.

\pnum
\effects Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream~(\ref{buffer.stream.reqmts.asyncwritestream}) object \tcode{stream} by performing zero or more asynchronous operations on the stream using the stream's \tcode{async_write_some} member function (henceforth referred to as asynchronous write_some operations).

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the \tcode{error_code} value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
The asynchronous write operation continues until:

\begin{itemize}
\item
the total number of bytes transferred is equal to \tcode{buffer_size(buffers)}; or
\item
the completion condition returns \tcode{0}.
\end{itemize}

\pnum
The program shall ensure the \tcode{AsyncWriteStream} object \tcode{stream} is valid until the completion handler for the asynchronous operation is invoked.

\pnum
On completion of the asynchronous operation, \tcode{ec} is the \tcode{error_code} value from the most recent asynchronous write_some operation, and \tcode{n} is the total number of bytes transferred.
\end{itemdescr}

\indexlibrary{\idxcode{async_write}}%
\begin{itemdecl}
template<class AsyncWriteStream, class DynamicBuffer, class CompletionToken>
  @\DEDUCED@ async_write(AsyncWriteStream& stream,
                      DynamicBuffer b, CompletionToken&& token);
template<class AsyncWriteStream, class DynamicBuffer, class CompletionCondition,
         class CompletionToken>
    @\DEDUCED@ async_write(AsyncWriteStream& stream,
                        DynamicBuffer b,
                        CompletionCondition completion_condition,
                        CompletionToken&& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
\completionsig \tcode{void(error_code ec, size_t n)}.

\pnum
\constraints
\tcode{is_dynamic_buffer_v<Dynamic\-Buffer>} is \tcode{true}.

\pnum
\effects Initiates an asynchronous operation to write data to the buffer-oriented asynchronous write stream~(\ref{buffer.stream.reqmts.asyncwritestream}) object \tcode{stream} by performing zero or more asynchronous write_some operations on the stream.

\pnum
Data is written from the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b}. A constant buffer sequence~(\ref{buffer.reqmts.constbuffersequence}) is obtained using \tcode{b.data()}. After the data has been written to the stream, the implementation performs \tcode{b.consume(n)}, where \tcode{n} is the number of bytes successfully written.

\pnum
The \tcode{completion_condition} parameter specifies a completion condition to be called prior to each asynchronous write_some operation. The completion condition is passed the \tcode{error_code} value from the most recent asynchronous write_some operation, and the total number of bytes transferred in the asynchronous write operation so far. The completion condition return value specifies the maximum number of bytes to be written on the subsequent asynchronous write_some operation. Overloads where a completion condition is not specified behave as if called with an object of class \tcode{transfer_all}.

\pnum
The asynchronous write operation continues until:

\begin{itemize}
\item \tcode{b.size() == 0}; or
\item the completion condition returns \tcode{0}.
\end{itemize}

\pnum
The program shall ensure both the \tcode{AsyncWriteStream} object \tcode{stream} and the memory associated with the dynamic buffer \tcode{b} are valid until the completion handler for the asynchronous operation is invoked.

\pnum
On completion of the asynchronous operation, \tcode{ec} is the \tcode{error_code} value from the most recent asynchronous write_some operation, and \tcode{n} is the total number of bytes transferred.
\end{itemdescr}



\rSec1[buffer.read.until]{Synchronous delimited read operations}

\indexlibrary{\idxcode{read_until}}%
\begin{itemdecl}
template<class SyncReadStream, class DynamicBuffer>
  size_t read_until(SyncReadStream& s, DynamicBuffer b, char delim);
template<class SyncReadStream, class DynamicBuffer>
  size_t read_until(SyncReadStream& s, DynamicBuffer b,
                    char delim, error_code& ec);
template<class SyncReadStream, class DynamicBuffer>
  size_t read_until(SyncReadStream& s, DynamicBuffer b, string_view delim);
template<class SyncReadStream, class DynamicBuffer>
  size_t read_until(SyncReadStream& s, DynamicBuffer b,
                    string_view delim, error_code& ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Reads data from the buffer-oriented synchronous read stream~(\ref{buffer.stream.reqmts.syncreadstream}) object \tcode{stream} by performing zero or more calls to the stream's \tcode{read_some} member function, until the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b} contains the specified delimiter \tcode{delim}.

\pnum
Data is placed into the dynamic buffer object \tcode{b}. A mutable buffer sequence~(\ref{buffer.reqmts.mutablebuffersequence}) \tcode{x} is obtained prior to each \tcode{read_some} call by performing:

\begin{codeblock}
auto orig_size = b.size();
b.grow(N);
auto x = b.data(orig_size, N);
\end{codeblock}

where \tcode{N} is an unspecified value such that \tcode{N <= max_size() - size()}. \begin{note} Implementations can use \tcode{b.capacity()} when determining \tcode{N}, to minimize the number of \tcode{read_some} calls performed on the stream. \end{note} After each \tcode{read_some} call, the implementation performs \tcode{b.shrink(N - n)}, where \tcode{n} is the return value from \tcode{read_some}.

\pnum
The synchronous read_until operation continues until:

\begin{itemize}
\item
\tcode{b} contains the delimiter \tcode{delim}; or
\item
\tcode{b.size() == b.max_size()}; or
\item
an asynchronous read_some operation fails.
\end{itemize}

\pnum
On exit, if \tcode{b} contains the delimiter, \tcode{ec} is set such that \tcode{!ec} is \tcode{true}. Otherwise, if \tcode{b.size() == b.max_size()}, \tcode{ec} is set such that \tcode{ec == stream_errc::not_found}. If \tcode{b.size() < b.max_size()}, \tcode{ec} contains the \tcode{error_code} from the most recent \tcode{read_some} call.

\pnum
\returns The number of bytes in \tcode{b} up to and including the delimiter, if present. \begin{note} On completion, the buffer can contain additional bytes following the delimiter. \end{note} Otherwise returns \tcode{0}.
\end{itemdescr}



\rSec1[buffer.async.read.until]{Asynchronous delimited read operations}

\indexlibrary{\idxcode{async_read_until}}%
\begin{itemdecl}
template<class AsyncReadStream, class DynamicBuffer, class CompletionToken>
  @\DEDUCED@ async_read_until(AsyncReadStream& s,
                           DynamicBuffer b, char delim,
                           CompletionToken&& token);
template<class AsyncReadStream, class DynamicBuffer, class CompletionToken>
  @\DEDUCED@ async_read_until(AsyncReadStream& s,
                           DynamicBuffer b, string_view delim,
                           CompletionToken&& token);
\end{itemdecl}

\begin{itemdescr}
\pnum
A composed asynchronous operation~(\ref{async.reqmts.async.composed}).

\pnum
\completionsig \tcode{void(error_code ec, size_t n)}.

\pnum
\effects Initiates an asynchronous operation to read data from the buffer-oriented asynchronous read stream~(\ref{buffer.stream.reqmts.asyncreadstream}) object \tcode{stream} by performing zero or more asynchronous read_some operations on the stream, until the dynamic buffer~(\ref{buffer.reqmts.dynamicbuffer}) object \tcode{b} contains the specified delimiter \tcode{delim}.

\pnum
Data is placed into the dynamic buffer object \tcode{b}. A mutable buffer sequence~(\ref{buffer.reqmts.mutablebuffersequence}) \tcode{x} is obtained prior to each \tcode{async_read_some} call by performing:

\begin{codeblock}
auto orig_size = b.size();
b.grow(N);
auto x = b.data(orig_size, N);
\end{codeblock}

where \tcode{N} is an unspecified value such that \tcode{N <= max_size() - size()}. \begin{note} Implementations can use \tcode{b.capacity()} when determining \tcode{N}, to minimize the number of asynchronous read_some operations performed on the stream. \end{note} After the completion of each asynchronous read_some operation, the implementation performs \tcode{b.shrink(N - n)}, where \tcode{n} is the value passed to the asynchronous read_some operation's completion handler.

\pnum
The asynchronous read_until operation continues until:

\begin{itemize}
\item
\tcode{b} contains the delimiter \tcode{delim}; or
\item
\tcode{b.size() == b.max_size()}; or
\item
an asynchronous read_some operation fails.
\end{itemize}

\pnum
The program shall ensure the \tcode{AsyncReadStream} object \tcode{stream} is valid until the completion handler for the asynchronous operation is invoked.

\pnum
If \tcode{delim} is of type \tcode{string_view}, the implementation copies the underlying sequence of characters prior to initiating an asynchronous read_some operation on the stream. \begin{note} This means that the caller is not required to guarantee the validity of the delimiter string after the call to \tcode{async_read_until} returns. \end{note}

\pnum
On completion of the asynchronous operation, if \tcode{b} contains the delimiter, \tcode{ec} is set such that \tcode{!ec} is \tcode{true}. Otherwise, if \tcode{b.size() == b.max_size()}, \tcode{ec} is set such that \tcode{ec == stream_errc::not_found}. If \tcode{b.size() < b.max_size()}, \tcode{ec} is the \tcode{error_code} from the most recent asynchronous read_some operation. \tcode{n} is the number of readable bytes in \tcode{b} up to and including the delimiter, if present, otherwise \tcode{0}.
\end{itemdescr}



